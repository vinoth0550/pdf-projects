nd.");
    }

    // If a type parameter's nullability depends on itself, it is deemed
    // 'undetermined'. Currently, it's possible if the type parameter has a
    // possibly nested FutureOr containing that type parameter.  If there are
    // other ways for such a dependency to exist, they should be checked here.
    bool nullabilityDependsOnItself = false;
    {
      DartType type = bound;
      while (type is FutureOrType) {
        type = type.typeArgument;
      }
      if (type is TypeParameterType && type.parameter == this) {
        nullabilityDependsOnItself = true;
      }
    }
    if (nullabilityDependsOnItself) {
      return Nullability.undetermined;
    }

    Nullability boundNullability =
        bound is InvalidType ? Nullability.undetermined : bound.nullability;
    return boundNullability == Nullability.nullable ||
            boundNullability == Nullability.undetermined
        ? Nullability.undetermined
        : boundNullability;
  }
}

/// Declaration of a type variable by a [FunctionType]
///
/// [StructuralParameter] objects should not be shared between different
/// [FunctionType] objects.
class StructuralParameter extends Node
    implements SharedTypeParameterStructure<DartType> {
  int flags = 0;

  String? name; // Cosmetic name.

  static const int noOffset = -1;

  /// Offset in the source file it comes from.
  ///
  /// Valid values are from 0 and up, or -1 ([noOffset]) if the file offset is
  /// not available (this is the default if none is specifically set).
  int fileOffset = noOffset;

  Uri? uri;

  /// Sentinel value used for the [bound] that has not yet been computed.
  ///
  /// This is needed to make the [bound] field non-nullable while supporting
  /// recursive bounds.
  static final DartType unsetBoundSentinel = new InvalidType();

  /// The bound on the type variable.
  ///
  /// This is set to [unsetBoundSentinel] temporarily during IR construction.
  /// This is set to the `Object?` for type parameters without an explicit
  /// bound.
  DartType bound;

  /// Sentinel value used for the [defaultType] that has not yet been computed.
  ///
  /// This is needed to make the [defaultType] field non-nullable while
  /// supporting recursive bounds for which the default type need to be set
  /// late.
  static final DartType unsetDefaultTypeSentinel = new InvalidType();

  /// The default value of the type variable.
  ///
  /// It is used to provide the corresponding missing type argument in type
  /// annotations and as the fall-back type value in type inference at compile
  /// time. At run time, [defaultType] is used by the backends in place of the
  /// missing type argument of a dynamic invocation of a generic function.
  DartType defaultType;

  /// Variance of type parameter w.r.t. declaration on which it is defined.
  Variance? _variance;

  @override
  String get displayName => name ?? '<unknown>';

  @override
  DartType? get boundShared => bound;

  Variance get variance => _variance ?? Variance.covariant;

  void set variance(Variance? newVariance) => _variance = newVariance;

  bool get isLegacyCovariant => _variance == null;

  static const int legacyCovariantSerializationMarker = 4;

  StructuralParameter([this.name, DartType? bound, DartType? defaultType])
      : bound = bound ?? unsetBoundSentinel,
        defaultType = defaultType ?? unsetDefaultTypeSentinel;

  @override
  R accept<R>(Visitor<R> v) => v.visitStructuralParameter(this);

  @override
  R accept1<R, A>(Visitor1<R, A> v, A arg) =>
      v.visitStructuralParameter(this, arg);

  @override
  void visitChildren(Visitor v) {
    bound.accept(v);
    defaultType.accept(v);
  }

  /// Returns a possibly synthesized name for this type parameter
  ///
  /// Consistent with the names used across all [toString] calls.
  @override
  String toString() {
    return "StructuralParameter(${toStringInternal()})";
  }

  @override
  void toTextInternal(AstPrinter printer) {
    printer.writeStructuralParameterName(this);
  }

  /// Computes the nullability of a structural parameter type based on [bound].
  ///
  /// This is a helper function to be used when the bound of the structural
  /// parameter is changing or is being set for the first time, and the update
  /// on some structural parameter types is required.
  Nullability computeNullabilityFromBound() {
    // If the bound is nullable or 'undetermined', both nullable and
    // non-nullable types can be passed in for the type parameter, making the
    // corresponding type parameter types 'undetermined.'  Otherwise, the
    // nullability matches that of the bound.
    if (identical(bound, StructuralParameter.unsetBoundSentinel)) {
      throw new StateError("Can't compute nullability from an absent bound.");
    }

    // If a type parameter's nullability depends on itself, it is deemed
    // 'undetermined'. Currently, it's possible if the type parameter has a
    // possibly nested FutureOr containing that type parameter.  If there are
    // other ways for such a dependency to exist, they should be checked here.
    bool nullabilityDependsOnItself = false;
    {
      DartType type = bound;
      while (type is FutureOrType) {
        type = type.typeArgument;
      }
      if (type is StructuralParameterType && type.parameter == this) {
        nullabilityDependsOnItself = true;
      }
    }
    if (nullabilityDependsOnItself) {
      return Nullability.undetermined;
    }

    Nullability boundNullability =
        bound is InvalidType ? Nullability.undetermined : bound.nullability;
    return boundNullability == Nullability.nullable ||
            boundNullability == Nullability.undetermined
        ? Nullability.undetermined
        : boundNullability;
  }
}

class Supertype extends Node {
  Reference className;
  final List<DartType> typeArguments;

  Supertype(Class classNode, List<DartType> typeArguments)
      : this.byReference(classNode.reference, typeArguments);

  Supertype.byReference(this.className, this.typeArguments);

  Class get classNode => className.asClass;

  @override
  R accept<R>(Visitor<R> v) => v.visitSupertype(this);

  @override
  R accept1<R, A>(Visitor1<R, A> v, A arg) => v.visitSupertype(this, arg);

  @override
  void visitChildren(Visitor v) {
    classNode.acceptReference(v);
    visitList(typeArguments, v);
  }

  InterfaceType get asInterfaceType {
    return new InterfaceType(
        classNode, classNode.enclosingLibrary.nonNullable, typeArguments);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is Supertype) {
      if (className != other.className) return false;
      if (typeArguments.length != other.typeArguments.length) return false;
      for (int i = 0; i < typeArguments.length; ++i) {
        if (typeArguments[i] != other.typeArguments[i]) return false;
      }
      return true;
    } else {
      return false;
    }
  }

  @override
  int get hashCode {
    int hash = 0x3fffffff & className.hashCode;
    for (int i = 0; i < typeArguments.length; ++i) {
      hash = 0x3fffffff & (hash * 31 + (hash ^ typeArguments[i].hashCode));
    }
    return hash;
  }

  @override
  String toString() {
    return "Supertype(${toStringInternal()})";
  }

  @override
  void toTextInternal(AstPrinter printer) {
    printer.writeClassName(className, forType: true);
    printer.writeTypeArguments(typeArguments);
  }
}

/// A syntax-independent notion of a type.
///
/// [DartType]s are not AST nodes and may be shared between different parents.
///
/// [DartType] objects should be treated as unmodifiable objects, although
/// immutability is not enforced for List fields, and [TypeParameter]s are
/// cyclic structures that are constructed by mutation.
///
/// The `==` operator on [DartType]s compare based on type equality, not
/// object identity.
sealed class DartType extends Node implements SharedTypeStructure<DartType> {
  const DartType();

  @override
  R accept<R>(DartTypeVisitor<R> v);

  @override
  R accept1<R, A>(DartTypeVisitor1<R, A> v, A arg);

  @override
  bool operator ==(Object other) => equals(other, null);

  /// The nullability declared on the type.
  ///
  /// For example, the declared nullability of `FutureOr<int?>` is
  /// [Nullability.nonNullable], the declared nullability of `dynamic` is
  /// [Nullability.nullable], the declared nullability of `int*` is
  /// [Nullability.legacy], the declared nullability of the promoted type `X &
  /// int` where `X extends Object?`
  /// is [Nullability.undetermined].
  Nullability get declaredNullability;

  /// The nullability of the type as the property to contain null.
  ///
  /// For example, nullability-as-property of FutureOr<int?> is
  /// [Nullability.nullable], nullability-as-property of dynamic is
  /// [Nullability.nullable], nullability-as-property of int* is
  /// [Nullability.legacy], nullability-as-property of the promoted type `X &
  /// int` where `X extends Object?`
  /// is [Nullability.nonNullable].
  Nullability get nullability;

  @override
  NullabilitySuffix get nullabilitySuffix {
    if (isTypeWithoutNullabilityMarker(this)) {
      return NullabilitySuffix.none;
    } else if (isNullableTypeConstructorApplication(this)) {
      return NullabilitySuffix.question;
    } else {
      assert(isLegacyTypeConstructorApplication(this));
      return NullabilitySuffix.star;
    }
  }

  /// If this is a typedef type, repeatedly unfolds its type definition until
  /// the root term is not a typedef type, otherwise returns the type itself.
  ///
  /// Will never return a typedef type.
  DartType get unalias => this;

  /// Creates a copy of the type with the given [declaredNullability].
  ///
  /// Some types have fixed nullabilities, such as `dynamic`, `invalid-type`,
  /// `void`, or `bottom`.
  DartType withDeclaredNullability(Nullability declaredNullability);

  /// Creates the type corresponding to this type without null, if possible.
  ///
  /// Note that not all types, for instance `dynamic`, have a corresponding
  /// non-nullable type. For these, the type itself is returned.
  ///
  /// This corresponds to the `NonNull` function of the nnbd specification.
  DartType toNonNull() => computeNonNull(this);

  /// Checks if the type is potentially nullable.
  ///
  /// A type is potentially nullable if it's nullable or if its nullability is
  /// undetermined at compile time.
  bool get isPotentiallyNullable {
    return nullability == Nullability.nullable ||
        nullability == Nullability.undetermined;
  }

  /// Checks if the type is potentially non-nullable.
  ///
  /// A type is potentially non-nullable if it's non-nullable or if its
  /// nullability is undetermined at compile time.
  bool get isPotentiallyNonNullable {
    return nullability == Nullability.nonNullable ||
        nullability == Nullability.undetermined;
  }

  /// Returns the non-type parameter bound of this type, taking nullability
  /// into account.
  ///
  /// For instance in
  ///
  ///     method<T, S extends Class, U extends S?>()
  ///
  /// the non-type parameter bound of `T` is `Object?`, for `S` it is `Class`,
  /// and for `U` it is `Class?`.
  DartType get nonTypeParameterBound;

  /// Returns `true` if members *not* declared on `Object` can be accessed on
  /// a receiver of this type.
  bool get hasNonObjectMemberAccess;

  /// Returns the type with all occurrences of [ExtensionType] replaced by their
  /// representations, transitively. This is the type used at runtime to
  /// represent this type.
  ///
  /// For instance, for these declarations
  ///
  ///    extension type ET1(int id) {}
  ///    extension type ET2(ET1 id) {}
  ///    extension type ET3<T>(T id) {}
  ///
  /// the extension type erasures for `ET1`, `ET2`, `ET3<ET2>` and `List<ET2>`
  /// are `int`, `int`, `int`, `List<int>`, respectively.
  DartType get extensionTypeErasure => computeExtensionTypeErasure(this);

  /// Internal implementation of equality using [assumptions] to handle equality
  /// of type parameters on function types coinductively.
  bool equals(Object other, Assumptions? assumptions);

  @override
  String getDisplayString() => toText(const AstTextStrategy());

  @override
  bool isStructurallyEqualTo(SharedTypeStructure other) {
    // TODO(cstefantsova): Use the actual algorithm for structural equality.
    return this == other;
  }

  /// Returns a textual representation of the this type.
  ///
  /// If [verbose] is `true`, qualified names will include the library name/uri.
  @override
  String toText(AstTextStrategy strategy) {
    AstPrinter printer = new AstPrinter(strategy);
    printer.writeType(this);
    return printer.getText();
  }

  @override
  void toTextInternal(AstPrinter printer);
}

/// A type which is 